/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package kz.kstu.cryptography.coursework;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.SecureRandom;

/**
 *
 * @author j3t1x
 */
public class Feistel extends javax.swing.JFrame {

    /**
     * Creates new form Feistel
     */
    public Feistel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setText("Выберете файл");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(108, 108, 108)
                .addComponent(jButton1)
                .addContainerGap(526, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(92, 92, 92)
                .addComponent(jButton1)
                .addContainerGap(385, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public static void init() {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Feistel.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Feistel.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Feistel.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Feistel.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Feistel().setVisible(true);
            }
        });
    }

    private static final int BLOCK_SIZE = 8; // блок размером 8 байт
    private static final int ROUNDS = 16; // количество раундов
    private static final int HALF_BLOCK_SIZE = BLOCK_SIZE / 2; // половина блока
    private static final int MASK = 0xff; // маска для получения последних 8 бит

    // функция для генерации раундовых ключей
    private static byte[][] generateRoundKeys(byte[] key) {
        byte[][] roundKeys = new byte[ROUNDS][HALF_BLOCK_SIZE];
        SecureRandom random = new SecureRandom(key);
        for (int i = 0; i < ROUNDS; i++) {
            random.nextBytes(roundKeys[i]);
        }
        return roundKeys;
    }

    // функция для преобразования блока данных
    private static byte[] feistel(byte[] block, byte[] key) {
        byte[] left = new byte[HALF_BLOCK_SIZE];
        byte[] right = new byte[HALF_BLOCK_SIZE];
        System.arraycopy(block, 0, left, 0, HALF_BLOCK_SIZE);
        System.arraycopy(block, HALF_BLOCK_SIZE, right, 0, HALF_BLOCK_SIZE);

        for (int i = 0; i < ROUNDS; i++) {
            byte[] temp = left;
            left = right;
            right = xor(temp, feistelRound(right, key));
        }

        byte[] result = new byte[BLOCK_SIZE];
        System.arraycopy(left, 0, result, 0, HALF_BLOCK_SIZE);
        System.arraycopy(right, 0, result, HALF_BLOCK_SIZE, HALF_BLOCK_SIZE);
        return result;
    }

    // функция для преобразования одного раунда
    private static byte[] feistelRound(byte[] block, byte[] key) {
        byte[] result = new byte[HALF_BLOCK_SIZE];
        byte[] expandedBlock = expandBlock(block);
        byte[] xored = xor(expandedBlock, key);
        for (int i = 0; i < HALF_BLOCK_SIZE; i++) {
            result[i] = sBox(xored[i]);
        }
        return result;
    }

    // функция для расширения блока данных
    private static byte[] expandBlock(byte[] block) {
        byte[] result = new byte[BLOCK_SIZE];
        System.arraycopy(block, 0, result, 0, HALF_BLOCK_SIZE);
        System.arraycopy(block, 0, result, HALF_BLOCK_SIZE, HALF_BLOCK_SIZE);
        return result;
    }
public static void encryptFile(String text, String fileName, byte[] key) throws IOException {
    FileInputStream inputStream = new FileInputStream(fileName);
    FileOutputStream outputStream = new FileOutputStream(fileName + ".enc");
    byte[][] roundKeys = generateRoundKeys(key);
    byte[] block = new byte[BLOCK_SIZE];
    byte[] temp = new byte[BLOCK_SIZE];
    int bytesRead;
    while ((bytesRead = inputStream.read(block)) > 0) {
        if (bytesRead < BLOCK_SIZE) {
            for (int i = bytesRead; i < BLOCK_SIZE; i++) {
                block[i] = 0;
            }
        }
        temp = feistel(block, roundKeys[0]);
        for (int i = 1; i < ROUNDS; i++) {
            byte[] t = temp;
            temp = feistel(temp, roundKeys[i]);
            roundKeys[i] = t;
        }
        outputStream.write(temp);
    }
    inputStream.close();
    outputStream.close();
}
private static byte sBox(byte b) {
        byte[] sTable = { 0x06, 0x0f, 0x03, 0x09, 0x00, 0x0d, 0x05, 0x01, 0x0b, 0x0c, 0x07, 0x0a, 0x02, 0x0e, 0x04 };
    return sTable[b & MASK];}
    // функция для выполнения операции xor
    private static byte[] xor(byte[] a, byte[] b) {
        byte[] result = new byte[a.length];
        for (int i = 0; i < a.length; i++) {
            result[i] = (byte) (a[i] ^ b[i]);
        }
        return result;
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    // End of variables declaration//GEN-END:variables
}
